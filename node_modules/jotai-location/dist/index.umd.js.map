{"version":3,"file":"index.umd.js","sources":["../src/atomWithLocation.ts","../src/atomWithHash.ts"],"sourcesContent":["import { atom } from 'jotai/vanilla';\nimport type { SetStateAction, WritableAtom } from 'jotai/vanilla';\n\ntype Location = {\n  pathname?: string;\n  searchParams?: URLSearchParams;\n  hash?: string;\n};\n\nconst getLocation = (): Location => {\n  if (typeof window === 'undefined' || !window.location) {\n    return {};\n  }\n  return {\n    pathname: window.location.pathname,\n    searchParams: new URLSearchParams(window.location.search),\n    hash: window.location.hash,\n  };\n};\n\nconst applyLocation = (\n  location: Location,\n  options?: { replace?: boolean },\n): void => {\n  const url = new URL(window.location.href);\n  if ('pathname' in location) {\n    url.pathname = location.pathname;\n  }\n  if ('searchParams' in location) {\n    url.search = location.searchParams.toString();\n  }\n  if ('hash' in location) {\n    url.hash = location.hash;\n  }\n  if (options?.replace) {\n    window.history.replaceState(window.history.state, '', url);\n  } else {\n    window.history.pushState(null, '', url);\n  }\n};\n\nconst subscribe = (callback: () => void) => {\n  window.addEventListener('popstate', callback);\n  return () => window.removeEventListener('popstate', callback);\n};\n\ntype Options<T> = {\n  preloaded?: T;\n  replace?: boolean;\n  getLocation?: () => T;\n  applyLocation?: (location: T, options?: { replace?: boolean }) => void;\n  subscribe?: (callback: () => void) => () => void;\n};\n\ntype RequiredOptions<T> = Omit<Options<T>, 'getLocation' | 'applyLocation'> &\n  Required<Pick<Options<T>, 'getLocation' | 'applyLocation'>>;\n\ntype AtomOptions<T> = Pick<Options<T>, 'replace'>;\n\nexport function atomWithLocation(\n  options?: Options<Location>,\n): WritableAtom<\n  Location,\n  [SetStateAction<Location>, AtomOptions<Location>?],\n  void\n>;\n\nexport function atomWithLocation<T>(\n  options: RequiredOptions<T>,\n): WritableAtom<T, [SetStateAction<T>, AtomOptions<T>?], void>;\n\nexport function atomWithLocation<T>(options?: Options<T>) {\n  const getL =\n    options?.getLocation ||\n    (getLocation as unknown as NonNullable<Options<T>['getLocation']>);\n  const appL =\n    options?.applyLocation ||\n    (applyLocation as unknown as NonNullable<Options<T>['applyLocation']>);\n  const sub = options?.subscribe || subscribe;\n  const baseAtom = atom(options?.preloaded ?? getL());\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseAtom.debugPrivate = true;\n  }\n\n  baseAtom.onMount = (set) => {\n    const callback = () => set(getL());\n    const unsub = sub(callback);\n    callback();\n    return unsub;\n  };\n  const derivedAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, arg: SetStateAction<T>, atomOptions: AtomOptions<T> = {}) => {\n      set(baseAtom, arg);\n      appL(get(baseAtom), { ...options, ...atomOptions });\n    },\n  );\n  return derivedAtom;\n}\n","import { atom } from 'jotai/vanilla';\nimport type { WritableAtom } from 'jotai/vanilla';\nimport { RESET } from 'jotai/vanilla/utils';\n\ntype SetStateActionWithReset<Value> =\n  | Value\n  | typeof RESET\n  | ((prev: Value) => Value | typeof RESET);\n\nconst safeJSONParse = (initialValue: unknown) => (str: string) => {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return initialValue;\n  }\n};\n\nexport type SetHashOption =\n  | 'default'\n  | 'replaceState'\n  | ((searchParams: string) => void);\n\nexport type AtomWithHashSetOptions = {\n  setHash?: SetHashOption;\n};\n\nexport const setHashWithPush = (searchParams: string) => {\n  window.location.hash = searchParams;\n};\n\nexport const setHashWithReplace = (searchParams: string): void => {\n  window.history.replaceState(\n    window.history.state,\n    '',\n    `${window.location.pathname}${window.location.search}#${searchParams}`,\n  );\n};\n\nfunction getSetHashFn(setHashOption?: SetHashOption) {\n  if (setHashOption === 'replaceState') {\n    return setHashWithReplace;\n  }\n  if (typeof setHashOption === 'function') {\n    return setHashOption;\n  }\n  return setHashWithPush;\n}\n\nexport function atomWithHash<Value>(\n  key: string,\n  initialValue: Value,\n  options?: {\n    serialize?: (val: Value) => string;\n    deserialize?: (str: string) => Value;\n    subscribe?: (callback: () => void) => () => void;\n    setHash?: SetHashOption;\n  },\n): WritableAtom<\n  Value,\n  [SetStateActionWithReset<Value>, AtomWithHashSetOptions?],\n  void\n> {\n  const serialize = options?.serialize || JSON.stringify;\n\n  const deserialize = options?.deserialize || safeJSONParse(initialValue);\n  const subscribe =\n    options?.subscribe ||\n    ((callback) => {\n      window.addEventListener('hashchange', callback);\n      return () => {\n        window.removeEventListener('hashchange', callback);\n      };\n    });\n\n  const isLocationAvailable =\n    typeof window !== 'undefined' && !!window.location;\n\n  const strAtom = atom(\n    isLocationAvailable\n      ? new URLSearchParams(window.location.hash.slice(1)).get(key)\n      : null,\n  );\n  strAtom.onMount = (setAtom) => {\n    if (!isLocationAvailable) {\n      return undefined;\n    }\n    const callback = () => {\n      setAtom(new URLSearchParams(window.location.hash.slice(1)).get(key));\n    };\n    const unsubscribe = subscribe(callback);\n    callback();\n    return unsubscribe;\n  };\n  const valueAtom = atom((get) => {\n    const str = get(strAtom);\n    return str === null ? initialValue : deserialize(str);\n  });\n  return atom(\n    (get) => get(valueAtom),\n    (\n      get,\n      set,\n      update: SetStateActionWithReset<Value>,\n      setOptions?: AtomWithHashSetOptions,\n    ) => {\n      const nextValue =\n        typeof update === 'function'\n          ? (update as (prev: Value) => Value | typeof RESET)(get(valueAtom))\n          : update;\n      const searchParams = new URLSearchParams(window.location.hash.slice(1));\n      if (nextValue === RESET) {\n        set(strAtom, null);\n        searchParams.delete(key);\n      } else {\n        const str = serialize(nextValue);\n        set(strAtom, str);\n        searchParams.set(key, str);\n      }\n      const setHash = getSetHashFn(setOptions?.setHash ?? options?.setHash);\n      setHash(searchParams.toString());\n    },\n  );\n}\n"],"names":["getLocation","window","location","pathname","searchParams","URLSearchParams","search","hash","applyLocation","options","url","URL","href","toString","replace","history","replaceState","state","pushState","subscribe","callback","addEventListener","removeEventListener","setHashWithPush","setHashWithReplace","key","initialValue","serialize","JSON","stringify","deserialize","str","parse","e","safeJSONParse","isLocationAvailable","strAtom","atom","slice","get","onMount","setAtom","unsubscribe","valueAtom","set","update","setOptions","_setOptions$setHash","setHashOption","nextValue","RESET","setHash","_options$preloaded","getL","appL","sub","baseAtom","preloaded","process","env","NODE_ENV","debugPrivate","unsub","arg","atomOptions","_extends"],"mappings":"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"}