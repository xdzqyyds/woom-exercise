{
  "version": 3,
  "sources": ["../../jotai/esm/react.mjs"],
  "sourcesContent": ["'use client';\nimport ReactExports, { createContext, useContext, useRef, createElement, useReducer, useEffect, useDebugValue, useCallback } from 'react';\nimport { getDefaultStore, createStore } from 'jotai/vanilla';\n\nconst StoreContext = createContext(\n  void 0\n);\nconst useStore = (options) => {\n  const store = useContext(StoreContext);\n  return (options == null ? void 0 : options.store) || store || getDefaultStore();\n};\nconst Provider = ({\n  children,\n  store\n}) => {\n  const storeRef = useRef();\n  if (!store && !storeRef.current) {\n    storeRef.current = createStore();\n  }\n  return createElement(\n    StoreContext.Provider,\n    {\n      value: store || storeRef.current\n    },\n    children\n  );\n};\n\nconst isPromiseLike = (x) => typeof (x == null ? void 0 : x.then) === \"function\";\nconst attachPromiseMeta = (promise) => {\n  promise.status = \"pending\";\n  promise.then(\n    (v) => {\n      promise.status = \"fulfilled\";\n      promise.value = v;\n    },\n    (e) => {\n      promise.status = \"rejected\";\n      promise.reason = e;\n    }\n  );\n};\nconst use = ReactExports.use || ((promise) => {\n  if (promise.status === \"pending\") {\n    throw promise;\n  } else if (promise.status === \"fulfilled\") {\n    return promise.value;\n  } else if (promise.status === \"rejected\") {\n    throw promise.reason;\n  } else {\n    attachPromiseMeta(promise);\n    throw promise;\n  }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise) => {\n  let continuablePromise = continuablePromiseMap.get(promise);\n  if (!continuablePromise) {\n    continuablePromise = new Promise((resolve, reject) => {\n      let curr = promise;\n      const onFulfilled = (me) => (v) => {\n        if (curr === me) {\n          resolve(v);\n        }\n      };\n      const onRejected = (me) => (e) => {\n        if (curr === me) {\n          reject(e);\n        }\n      };\n      const registerCancelHandler = (p) => {\n        if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\n          p.onCancel((nextValue) => {\n            if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && nextValue === p) {\n              throw new Error(\"[Bug] p is not updated even after cancelation\");\n            }\n            if (isPromiseLike(nextValue)) {\n              continuablePromiseMap.set(nextValue, continuablePromise);\n              curr = nextValue;\n              nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n              registerCancelHandler(nextValue);\n            } else {\n              resolve(nextValue);\n            }\n          });\n        }\n      };\n      promise.then(onFulfilled(promise), onRejected(promise));\n      registerCancelHandler(promise);\n    });\n    continuablePromiseMap.set(promise, continuablePromise);\n  }\n  return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n  const store = useStore(options);\n  const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = useReducer(\n    (prev) => {\n      const nextValue = store.get(atom);\n      if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n        return prev;\n      }\n      return [nextValue, store, atom];\n    },\n    void 0,\n    () => [store.get(atom), store, atom]\n  );\n  let value = valueFromReducer;\n  if (storeFromReducer !== store || atomFromReducer !== atom) {\n    rerender();\n    value = store.get(atom);\n  }\n  const delay = options == null ? void 0 : options.delay;\n  useEffect(() => {\n    const unsub = store.sub(atom, () => {\n      if (typeof delay === \"number\") {\n        const value2 = store.get(atom);\n        if (isPromiseLike(value2)) {\n          attachPromiseMeta(createContinuablePromise(value2));\n        }\n        setTimeout(rerender, delay);\n        return;\n      }\n      rerender();\n    });\n    rerender();\n    return unsub;\n  }, [store, atom, delay]);\n  useDebugValue(value);\n  if (isPromiseLike(value)) {\n    const promise = createContinuablePromise(value);\n    return use(promise);\n  }\n  return value;\n}\n\nfunction useSetAtom(atom, options) {\n  const store = useStore(options);\n  const setAtom = useCallback(\n    (...args) => {\n      if ((import.meta.env ? import.meta.env.MODE : void 0) !== \"production\" && !(\"write\" in atom)) {\n        throw new Error(\"not writable atom\");\n      }\n      return store.set(atom, ...args);\n    },\n    [store, atom]\n  );\n  return setAtom;\n}\n\nfunction useAtom(atom, options) {\n  return [\n    useAtomValue(atom, options),\n    // We do wrong type assertion here, which results in throwing an error.\n    useSetAtom(atom, options)\n  ];\n}\n\nexport { Provider, useAtom, useAtomValue, useSetAtom, useStore };\n"],
  "mappings": "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",
  "names": ["ReactExports"]
}
