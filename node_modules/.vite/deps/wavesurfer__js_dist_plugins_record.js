import "./chunk-5WWUZCGV.js";

// node_modules/wavesurfer.js/dist/plugins/record.js
function t(t2, i2, e2, s2) {
  return new (e2 || (e2 = Promise))(function(o2, r2) {
    function n(t3) {
      try {
        d(s2.next(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function a(t3) {
      try {
        d(s2.throw(t3));
      } catch (t4) {
        r2(t4);
      }
    }
    function d(t3) {
      var i3;
      t3.done ? o2(t3.value) : (i3 = t3.value, i3 instanceof e2 ? i3 : new e2(function(t4) {
        t4(i3);
      })).then(n, a);
    }
    d((s2 = s2.apply(t2, i2 || [])).next());
  });
}
var i = class {
  constructor() {
    this.listeners = {};
  }
  on(t2, i2, e2) {
    if (this.listeners[t2] || (this.listeners[t2] = /* @__PURE__ */ new Set()), this.listeners[t2].add(i2), null == e2 ? void 0 : e2.once) {
      const e3 = () => {
        this.un(t2, e3), this.un(t2, i2);
      };
      return this.on(t2, e3), e3;
    }
    return () => this.un(t2, i2);
  }
  un(t2, i2) {
    var e2;
    null === (e2 = this.listeners[t2]) || void 0 === e2 || e2.delete(i2);
  }
  once(t2, i2) {
    return this.on(t2, i2, { once: true });
  }
  unAll() {
    this.listeners = {};
  }
  emit(t2, ...i2) {
    this.listeners[t2] && this.listeners[t2].forEach((t3) => t3(...i2));
  }
};
var e = class extends i {
  constructor(t2) {
    super(), this.subscriptions = [], this.options = t2;
  }
  onInit() {
  }
  _init(t2) {
    this.wavesurfer = t2, this.onInit();
  }
  destroy() {
    this.emit("destroy"), this.subscriptions.forEach((t2) => t2());
  }
};
var s = class extends i {
  constructor() {
    super(...arguments), this.unsubscribe = () => {
    };
  }
  start() {
    this.unsubscribe = this.on("tick", () => {
      requestAnimationFrame(() => {
        this.emit("tick");
      });
    }), this.emit("tick");
  }
  stop() {
    this.unsubscribe();
  }
  destroy() {
    this.unsubscribe();
  }
};
var o = ["audio/webm", "audio/wav", "audio/mpeg", "audio/mp4", "audio/mp3"];
var r = class _r extends e {
  constructor(t2) {
    var i2, e2, o2, r2, n, a;
    super(Object.assign(Object.assign({}, t2), { audioBitsPerSecond: null !== (i2 = t2.audioBitsPerSecond) && void 0 !== i2 ? i2 : 128e3, scrollingWaveform: null !== (e2 = t2.scrollingWaveform) && void 0 !== e2 && e2, scrollingWaveformWindow: null !== (o2 = t2.scrollingWaveformWindow) && void 0 !== o2 ? o2 : 5, continuousWaveform: null !== (r2 = t2.continuousWaveform) && void 0 !== r2 && r2, renderRecordedAudio: null === (n = t2.renderRecordedAudio) || void 0 === n || n, mediaRecorderTimeslice: null !== (a = t2.mediaRecorderTimeslice) && void 0 !== a ? a : void 0 })), this.stream = null, this.mediaRecorder = null, this.dataWindow = null, this.isWaveformPaused = false, this.lastStartTime = 0, this.lastDuration = 0, this.duration = 0, this.timer = new s(), this.subscriptions.push(this.timer.on("tick", () => {
      const t3 = performance.now() - this.lastStartTime;
      this.duration = this.isPaused() ? this.duration : this.lastDuration + t3, this.emit("record-progress", this.duration);
    }));
  }
  static create(t2) {
    return new _r(t2 || {});
  }
  renderMicStream(t2) {
    var i2;
    const e2 = new AudioContext(), s2 = e2.createMediaStreamSource(t2), o2 = e2.createAnalyser();
    s2.connect(o2), this.options.continuousWaveform && (o2.fftSize = 32);
    const r2 = o2.frequencyBinCount, n = new Float32Array(r2);
    let a = 0;
    this.wavesurfer && (null !== (i2 = this.originalOptions) && void 0 !== i2 || (this.originalOptions = Object.assign({}, this.wavesurfer.options)), this.wavesurfer.options.interact = false, this.options.scrollingWaveform && (this.wavesurfer.options.cursorWidth = 0));
    const d = setInterval(() => {
      var t3, i3, s3, d2;
      if (!this.isWaveformPaused) {
        if (o2.getFloatTimeDomainData(n), this.options.scrollingWaveform) {
          const t4 = Math.floor((this.options.scrollingWaveformWindow || 0) * e2.sampleRate), i4 = Math.min(t4, this.dataWindow ? this.dataWindow.length + r2 : r2), s4 = new Float32Array(t4);
          if (this.dataWindow) {
            const e3 = Math.max(0, t4 - this.dataWindow.length);
            s4.set(this.dataWindow.slice(-i4 + r2), e3);
          }
          s4.set(n, t4 - r2), this.dataWindow = s4;
        } else if (this.options.continuousWaveform) {
          if (!this.dataWindow) {
            const e4 = this.options.continuousWaveformDuration ? Math.round(100 * this.options.continuousWaveformDuration) : (null !== (i3 = null === (t3 = this.wavesurfer) || void 0 === t3 ? void 0 : t3.getWidth()) && void 0 !== i3 ? i3 : 0) * window.devicePixelRatio;
            this.dataWindow = new Float32Array(e4);
          }
          let e3 = 0;
          for (let t4 = 0; t4 < r2; t4++) {
            const i4 = Math.abs(n[t4]);
            i4 > e3 && (e3 = i4);
          }
          if (a + 1 > this.dataWindow.length) {
            const t4 = new Float32Array(2 * this.dataWindow.length);
            t4.set(this.dataWindow, 0), this.dataWindow = t4;
          }
          this.dataWindow[a] = e3, a++;
        } else
          this.dataWindow = n;
        if (this.wavesurfer) {
          const t4 = (null !== (d2 = null === (s3 = this.dataWindow) || void 0 === s3 ? void 0 : s3.length) && void 0 !== d2 ? d2 : 0) / 100;
          this.wavesurfer.load("", [this.dataWindow], this.options.scrollingWaveform ? this.options.scrollingWaveformWindow : t4).then(() => {
            this.wavesurfer && this.options.continuousWaveform && (this.wavesurfer.setTime(this.getDuration() / 1e3), this.wavesurfer.options.minPxPerSec || this.wavesurfer.setOptions({ minPxPerSec: this.wavesurfer.getWidth() / this.wavesurfer.getDuration() }));
          }).catch((t5) => {
            console.error("Error rendering real-time recording data:", t5);
          });
        }
      }
    }, 10);
    return { onDestroy: () => {
      clearInterval(d), null == s2 || s2.disconnect(), null == e2 || e2.close();
    }, onEnd: () => {
      this.isWaveformPaused = true, clearInterval(d), this.stopMic();
    } };
  }
  startMic(i2) {
    return t(this, void 0, void 0, function* () {
      let t2;
      try {
        t2 = yield navigator.mediaDevices.getUserMedia({ audio: !(null == i2 ? void 0 : i2.deviceId) || { deviceId: i2.deviceId } });
      } catch (t3) {
        throw new Error("Error accessing the microphone: " + t3.message);
      }
      const { onDestroy: e2, onEnd: s2 } = this.renderMicStream(t2);
      return this.subscriptions.push(this.once("destroy", e2)), this.subscriptions.push(this.once("record-end", s2)), this.stream = t2, t2;
    });
  }
  stopMic() {
    this.stream && (this.stream.getTracks().forEach((t2) => t2.stop()), this.stream = null, this.mediaRecorder = null);
  }
  startRecording(i2) {
    return t(this, void 0, void 0, function* () {
      const t2 = this.stream || (yield this.startMic(i2));
      this.dataWindow = null;
      const e2 = this.mediaRecorder || new MediaRecorder(t2, { mimeType: this.options.mimeType || o.find((t3) => MediaRecorder.isTypeSupported(t3)), audioBitsPerSecond: this.options.audioBitsPerSecond });
      this.mediaRecorder = e2, this.stopRecording();
      const s2 = [];
      e2.ondataavailable = (t3) => {
        t3.data.size > 0 && s2.push(t3.data), this.emit("record-data-available", t3.data);
      };
      const r2 = (t3) => {
        var i3;
        const o2 = new Blob(s2, { type: e2.mimeType });
        this.emit(t3, o2), this.options.renderRecordedAudio && (this.applyOriginalOptionsIfNeeded(), null === (i3 = this.wavesurfer) || void 0 === i3 || i3.load(URL.createObjectURL(o2)));
      };
      e2.onpause = () => r2("record-pause"), e2.onstop = () => r2("record-end"), e2.start(this.options.mediaRecorderTimeslice), this.lastStartTime = performance.now(), this.lastDuration = 0, this.duration = 0, this.isWaveformPaused = false, this.timer.start(), this.emit("record-start");
    });
  }
  getDuration() {
    return this.duration;
  }
  isRecording() {
    var t2;
    return "recording" === (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  isPaused() {
    var t2;
    return "paused" === (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  isActive() {
    var t2;
    return "inactive" !== (null === (t2 = this.mediaRecorder) || void 0 === t2 ? void 0 : t2.state);
  }
  stopRecording() {
    var t2;
    this.isActive() && (null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.stop(), this.timer.stop());
  }
  pauseRecording() {
    var t2, i2;
    this.isRecording() && (this.isWaveformPaused = true, null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.requestData(), null === (i2 = this.mediaRecorder) || void 0 === i2 || i2.pause(), this.timer.stop(), this.lastDuration = this.duration);
  }
  resumeRecording() {
    var t2;
    this.isPaused() && (this.isWaveformPaused = false, null === (t2 = this.mediaRecorder) || void 0 === t2 || t2.resume(), this.timer.start(), this.lastStartTime = performance.now(), this.emit("record-resume"));
  }
  static getAvailableAudioDevices() {
    return t(this, void 0, void 0, function* () {
      return navigator.mediaDevices.enumerateDevices().then((t2) => t2.filter((t3) => "audioinput" === t3.kind));
    });
  }
  destroy() {
    this.applyOriginalOptionsIfNeeded(), super.destroy(), this.stopRecording(), this.stopMic();
  }
  applyOriginalOptionsIfNeeded() {
    this.wavesurfer && this.originalOptions && (this.wavesurfer.setOptions(this.originalOptions), delete this.originalOptions);
  }
};
export {
  r as default
};
//# sourceMappingURL=wavesurfer__js_dist_plugins_record.js.map
