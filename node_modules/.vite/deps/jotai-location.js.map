{
  "version": 3,
  "sources": ["../../jotai-location/src/atomWithLocation.ts", "../../jotai-location/src/atomWithHash.ts"],
  "sourcesContent": ["import { atom } from 'jotai/vanilla';\nimport type { SetStateAction, WritableAtom } from 'jotai/vanilla';\n\ntype Location = {\n  pathname?: string;\n  searchParams?: URLSearchParams;\n  hash?: string;\n};\n\nconst getLocation = (): Location => {\n  if (typeof window === 'undefined' || !window.location) {\n    return {};\n  }\n  return {\n    pathname: window.location.pathname,\n    searchParams: new URLSearchParams(window.location.search),\n    hash: window.location.hash,\n  };\n};\n\nconst applyLocation = (\n  location: Location,\n  options?: { replace?: boolean },\n): void => {\n  const url = new URL(window.location.href);\n  if ('pathname' in location) {\n    url.pathname = location.pathname;\n  }\n  if ('searchParams' in location) {\n    url.search = location.searchParams.toString();\n  }\n  if ('hash' in location) {\n    url.hash = location.hash;\n  }\n  if (options?.replace) {\n    window.history.replaceState(window.history.state, '', url);\n  } else {\n    window.history.pushState(null, '', url);\n  }\n};\n\nconst subscribe = (callback: () => void) => {\n  window.addEventListener('popstate', callback);\n  return () => window.removeEventListener('popstate', callback);\n};\n\ntype Options<T> = {\n  preloaded?: T;\n  replace?: boolean;\n  getLocation?: () => T;\n  applyLocation?: (location: T, options?: { replace?: boolean }) => void;\n  subscribe?: (callback: () => void) => () => void;\n};\n\ntype RequiredOptions<T> = Omit<Options<T>, 'getLocation' | 'applyLocation'> &\n  Required<Pick<Options<T>, 'getLocation' | 'applyLocation'>>;\n\ntype AtomOptions<T> = Pick<Options<T>, 'replace'>;\n\nexport function atomWithLocation(\n  options?: Options<Location>,\n): WritableAtom<\n  Location,\n  [SetStateAction<Location>, AtomOptions<Location>?],\n  void\n>;\n\nexport function atomWithLocation<T>(\n  options: RequiredOptions<T>,\n): WritableAtom<T, [SetStateAction<T>, AtomOptions<T>?], void>;\n\nexport function atomWithLocation<T>(options?: Options<T>) {\n  const getL =\n    options?.getLocation ||\n    (getLocation as unknown as NonNullable<Options<T>['getLocation']>);\n  const appL =\n    options?.applyLocation ||\n    (applyLocation as unknown as NonNullable<Options<T>['applyLocation']>);\n  const sub = options?.subscribe || subscribe;\n  const baseAtom = atom(options?.preloaded ?? getL());\n\n  if (process.env.NODE_ENV !== 'production') {\n    baseAtom.debugPrivate = true;\n  }\n\n  baseAtom.onMount = (set) => {\n    const callback = () => set(getL());\n    const unsub = sub(callback);\n    callback();\n    return unsub;\n  };\n  const derivedAtom = atom(\n    (get) => get(baseAtom),\n    (get, set, arg: SetStateAction<T>, atomOptions: AtomOptions<T> = {}) => {\n      set(baseAtom, arg);\n      appL(get(baseAtom), { ...options, ...atomOptions });\n    },\n  );\n  return derivedAtom;\n}\n", "import { atom } from 'jotai/vanilla';\nimport type { WritableAtom } from 'jotai/vanilla';\nimport { RESET } from 'jotai/vanilla/utils';\n\ntype SetStateActionWithReset<Value> =\n  | Value\n  | typeof RESET\n  | ((prev: Value) => Value | typeof RESET);\n\nconst safeJSONParse = (initialValue: unknown) => (str: string) => {\n  try {\n    return JSON.parse(str);\n  } catch (e) {\n    return initialValue;\n  }\n};\n\nexport type SetHashOption =\n  | 'default'\n  | 'replaceState'\n  | ((searchParams: string) => void);\n\nexport type AtomWithHashSetOptions = {\n  setHash?: SetHashOption;\n};\n\nexport const setHashWithPush = (searchParams: string) => {\n  window.location.hash = searchParams;\n};\n\nexport const setHashWithReplace = (searchParams: string): void => {\n  window.history.replaceState(\n    window.history.state,\n    '',\n    `${window.location.pathname}${window.location.search}#${searchParams}`,\n  );\n};\n\nfunction getSetHashFn(setHashOption?: SetHashOption) {\n  if (setHashOption === 'replaceState') {\n    return setHashWithReplace;\n  }\n  if (typeof setHashOption === 'function') {\n    return setHashOption;\n  }\n  return setHashWithPush;\n}\n\nexport function atomWithHash<Value>(\n  key: string,\n  initialValue: Value,\n  options?: {\n    serialize?: (val: Value) => string;\n    deserialize?: (str: string) => Value;\n    subscribe?: (callback: () => void) => () => void;\n    setHash?: SetHashOption;\n  },\n): WritableAtom<\n  Value,\n  [SetStateActionWithReset<Value>, AtomWithHashSetOptions?],\n  void\n> {\n  const serialize = options?.serialize || JSON.stringify;\n\n  const deserialize = options?.deserialize || safeJSONParse(initialValue);\n  const subscribe =\n    options?.subscribe ||\n    ((callback) => {\n      window.addEventListener('hashchange', callback);\n      return () => {\n        window.removeEventListener('hashchange', callback);\n      };\n    });\n\n  const isLocationAvailable =\n    typeof window !== 'undefined' && !!window.location;\n\n  const strAtom = atom(\n    isLocationAvailable\n      ? new URLSearchParams(window.location.hash.slice(1)).get(key)\n      : null,\n  );\n  strAtom.onMount = (setAtom) => {\n    if (!isLocationAvailable) {\n      return undefined;\n    }\n    const callback = () => {\n      setAtom(new URLSearchParams(window.location.hash.slice(1)).get(key));\n    };\n    const unsubscribe = subscribe(callback);\n    callback();\n    return unsubscribe;\n  };\n  const valueAtom = atom((get) => {\n    const str = get(strAtom);\n    return str === null ? initialValue : deserialize(str);\n  });\n  return atom(\n    (get) => get(valueAtom),\n    (\n      get,\n      set,\n      update: SetStateActionWithReset<Value>,\n      setOptions?: AtomWithHashSetOptions,\n    ) => {\n      const nextValue =\n        typeof update === 'function'\n          ? (update as (prev: Value) => Value | typeof RESET)(get(valueAtom))\n          : update;\n      const searchParams = new URLSearchParams(window.location.hash.slice(1));\n      if (nextValue === RESET) {\n        set(strAtom, null);\n        searchParams.delete(key);\n      } else {\n        const str = serialize(nextValue);\n        set(strAtom, str);\n        searchParams.set(key, str);\n      }\n      const setHash = getSetHashFn(setOptions?.setHash ?? options?.setHash);\n      setHash(searchParams.toString());\n    },\n  );\n}\n"],
  "mappings": "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",
  "names": ["getLocation", "window", "location", "pathname", "searchParams", "URLSearchParams", "search", "hash", "applyLocation", "options", "url", "URL", "href", "toString", "replace", "history", "replaceState", "state", "pushState", "subscribe", "callback", "addEventListener", "removeEventListener", "atomWithLocation", "_options$preloaded", "getL", "appL", "sub", "baseAtom", "atom", "preloaded", "debugPrivate", "onMount", "set", "unsub", "get", "arg", "atomOptions", "_extends", "setHashWithPush", "setHashWithReplace", "atomWithHash", "key", "initialValue", "serialize", "JSON", "stringify", "deserialize", "str", "parse", "e", "isLocationAvailable", "strAtom", "slice", "setAtom", "unsubscribe", "valueAtom", "update", "setOptions", "_setOptions$setHash", "nextValue", "RESET", "delete", "setHashOption", "setHash"]
}
